/* autogenerated by Processing revision 1294 on 2024-12-15 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class fireSim extends PApplet {

//State variable constants
int DIRT = 0;
int FIRE = 1;
int BURNT = 2;
int TREE = 3;

//color values
int DIRT_COLOR = 0xFF81582F;
int FIRE_COLOR = 0xFFF20C0C;
int BURNT_COLOR = 0xFF810707;
int TREE_COLOR = 0xFF49B90D;

//Constats for Forrest setup
int TREE_DENSITY = 60;
int NUM_TRACTS = 100;
int TRACT_LENGTH = 100;


//Driver variables
boolean burning;
int spreadPattern; //1 | 4 | 8
Forrest f;

public void setup() {
  /* size commented out by preprocessor */;
  frameRate(10);

  burning = false;
  spreadPattern = 1;
  textSize(30);
  f = new Forrest(NUM_TRACTS, TRACT_LENGTH, TREE_DENSITY);
}//setup

public void draw() {
  background(255);
  f.displayAll();
  if (burning) {
    if (spreadPattern==1) {
      f.spread1();
    } else if (spreadPattern==4) {
      f.spread4();
    } else if (spreadPattern==8) {
      f.spread8();
    }
  }
  fill(0);
  if (spreadPattern==1) {
      text("Spread Pattern: 1",100,40);
    } else if (spreadPattern==4) {
      text("Spread Pattern: 4",100,40);
    } else if (spreadPattern==8) {
      text("Spread Pattern: 8",100,40);
    }
}//draw

public void keyPressed() {
  if (key==' ') {
    burning=!burning;
  }
  if (key=='r') {
    burning=false;
    f = new Forrest(NUM_TRACTS, TRACT_LENGTH, TREE_DENSITY);
  }
  if (key=='1') {
    spreadPattern=1;
  }
  if (key=='4') {
    spreadPattern=4;
  }
  if (key=='8') {
    spreadPattern=8;
  }
}//keyPressed
class Forrest {
  Land[][] forest;
  int s;
  Forrest (int numRows, int numCols, int treeDensity) {
    forest= new Land[numRows][numCols];
    s=width/numCols;
    createForest(treeDensity);
  }//constructor
  public void createForest (int treeDensity) {
    for (int r=0; r<forest.length; r++) {
      for (int c=0; c<forest[r].length; c++) {
        if (c==0) {
          forest[r][c]=new Land(s*c, s*r+50, s, FIRE);
        } else {
          float v=random(100);
          if (v<=treeDensity) {
            forest[r][c]=new Land(s*c, s*r+50, s, TREE);
          } else {
            forest[r][c]=new Land(s*c, s*r+50, s, DIRT);
          }
        }
      }
    }
  }// instantiate forest with Lands
  public void displayAll () {
    for (int r=0; r<forest.length; r++) {
      for (int c=0; c<forest[r].length; c++) {
        forest[r][c].display();
      }
    }
  }// display() all Lands in forest
  public void spread1() {
    for (int r=0; r<forest.length; r++) {
      for (int c=0; c<forest[r].length; c++) {
        int neighborState=FIRE;
        if (c>0) {
          neighborState=forest[r][c-1].state;
        }
        forest[r][c].updateNextState(neighborState);
      }
    }
    for (int r=0; r<forest.length; r++) {
      for (int c=0; c<forest[r].length; c++) {
        forest[r][c].changeState();
      }
    }
  }// spread 1
  public void spread4() {
    for (int r=0; r<forest.length; r++) {
      for (int c=0; c<forest[r].length; c++) {
        int neighborState=DIRT;
        boolean fire=false;
        if (c>0) {
          if (forest[r][c-1].state==FIRE) {
            fire=true;
          }
        }
        if (c<(forest[r].length-1)&&!fire) {
          if (forest[r][c+1].state==FIRE) {
            fire=true;
          }
        }
        if (r>0&&!fire) {
          if (forest[r-1][c].state==FIRE) {
            fire=true;
          }
        }
        if (r<(forest.length-1)&&!fire) {
          if (forest[r+1][c].state==FIRE) {
            fire=true;
          }
        }
        if (fire) {
          neighborState=FIRE;
        }
        forest[r][c].updateNextState(neighborState);
      }
    }
    for (int r=0; r<forest.length; r++) {
      for (int c=0; c<forest[r].length; c++) {
        forest[r][c].changeState();
      }
    }
  }// spread 4
  public void spread8() {
    for (int r=0; r<forest.length; r++) {
      for (int c=0; c<forest[r].length; c++) {
        int neighborState=DIRT;
        boolean fire=false;
        if (c>0) {
          if (forest[r][c-1].state==FIRE) {
            fire=true;
          }
        }
        if (c<(forest[r].length-1)&&!fire) {
          if (forest[r][c+1].state==FIRE) {
            fire=true;
          }
        }
        if (r>0&&!fire) {
          if (forest[r-1][c].state==FIRE) {
            fire=true;
          }
        }
        if (r<(forest.length-1)&&!fire) {
          if (forest[r+1][c].state==FIRE) {
            fire=true;
          }
        }
        if (c>0&&r>0&&!fire) {
          if (forest[r-1][c-1].state==FIRE) {
            fire=true;
          }
        }
        if (c<(forest[r].length-1)&&r>0&&!fire) {
          if (forest[r-1][c+1].state==FIRE) {
            fire=true;
          }
        }
        if (r<(forest.length-1)&&c<(forest[r].length-1)&&!fire) {
          if (forest[r+1][c+1].state==FIRE) {
            fire=true;
          }
        }
        if (r<(forest.length-1)&&c>0&&!fire) {
          if (forest[r+1][c-1].state==FIRE) {
            fire=true;
          }
        }
        if (fire) {
          neighborState=FIRE;
        }
        forest[r][c].updateNextState(neighborState);
      }
    }
    for (int r=0; r<forest.length; r++) {
      for (int c=0; c<forest[r].length; c++) {
        forest[r][c].changeState();
      }
    }
  }// spread 8
}//class Forrest
class Land {

  //display related fields
  int size;
  PVector corner;

  //current state and next state
  int state;
  int nextState;


  Land(int _x, int _y, int sz, int st) {
    corner = new PVector(_x, _y);
    size = sz;
    state = st;
  }

  public void display() {
    //set fill color based on state
    if (state == DIRT) {
      fill(DIRT_COLOR);
    }
    else if (state == FIRE) {
      fill(FIRE_COLOR);
    }
    else if (state == BURNT) {
      fill(BURNT_COLOR);
    }
    else if (state == TREE) {
      fill(TREE_COLOR);
    }
    square(corner.x, corner.y, size);
  }

  //set nextState based on current state and possibly neighborState
  public void updateNextState(int neighborState) {
    if (state == FIRE) {
      nextState = BURNT;
    }
    else if (state == TREE && neighborState  == FIRE) {
      nextState = FIRE;
    }
    else {
      nextState = state;
    }
  }//updateState

  public void changeState() {
    state = nextState;
  }//changeState

}//Land class


  public void settings() { size(700, 750); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "fireSim" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
